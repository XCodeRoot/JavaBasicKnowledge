# 集群篇

## 主从同步

### CAP 原理

CAP 原理是分布式存储的理论基石。

-   C：Consistent，一致性
-   A：Availability，可用性
-   P：Partition tolerance，分区容错性

分布式系统的节点往往都是分布在不同的机器上进行网络隔离开的，这意味着必然会有网络断开的风险，这个网络断开的场景的专业词汇叫做网络分区。

用一句话概括 CAP 原理就是：当网络分区发生时，一致性和可用性两难全。

### 最终一致

Redis 的主从数据是异步同步的，所以分布式的 Redis 系统并不满足一致性，当客户端在 Redis 的主节点修改了数据后，立即返回，即使在主从网络断开的情况下，主节点依旧可以正常对外提供修改服务，所以 Redis 满足可用性。

### 主从同步与从从同步

从从同步是 Redis 后续版本增加的功能，以减轻主节点的同步负担。

### 增量同步

Redis 同步的是指令流，主节点会将那些对自己的状态产生修改性影响的指令记录在本地的内存 buffer 中，然后异步将 buffer 中的指令同步到从节点，从节点一边执行同步的指令流来达到和主节点一样的状态，一边向主节点反馈自己同步到哪里了(偏移量)。

Redis 的复制内存 buffer 是一个定长的环形数组，如果数组内容满了，就会从头开始覆盖前面的内容。

如果因为网络状态不好，从节点在短时间内无法和主节点进行同步，那么当网络状况恢复时，Redis 的主节点汇中那些没有同步的指令在 buffer 中有可能已经被后续的指令覆盖掉了，从节点将无法直接通过指令流来进行同步，这时候就需要快照同步。

### 快照同步

快照同步是一个非常耗资源的操作，它首先需要在主节点上进行一次 bgsave，将当前内存的数据全部快照到磁盘文件中，然后再将快照文件的内容全部传送到从节点。从节点将快照文件接受完毕后，立即执行一次全量加载，加载之前先要将当前内存的数据清空，加载完毕后通知主节点继续进行增量同步。

### 增加从节点

当从节点刚刚加入到集群时，它必须先进行一次快照同步，同步完成后再继续进行增量同步。

### 无盘复制

无盘复制是指主服务器直接通过套接字将快照内容发送到从节点，生成快照是一个遍历的过程，主节点会一边遍历内存，一边将序列化的内容发送到从节点，从节点还是跟之前一样，先将收到的内容存储到磁盘中，再进行一次性加载。

### wait 指令

Redis 的复制是异步进行的，wait 指令可以让异步复制变身同步复制，确保系统的强一致性。

```shell
> set key value
OK
> wait 1 0
(integer) 1
```

Wait 提供两个参数，第一个参数是从节点的数量 N，第二个参数是时间 t，以毫秒为单位。两个参数的含义是：等待 wait 指令之前的所有写操作同步到 N 个从节点，最多等待时间 t。

## Sentinel

Sentinel 负责持续监控主从节点的健康，当主节点挂掉时，自动选择一个最优的从节点切换成为主节点。客户端来连接集群时，会首先连接 Sentinel，通过 Sentinel 来查询主节点的地址，然后再连接主节点进行数据交互。当主节点发生故障时，客户端会重新向 Sentinel 要地址，Sentinel 会将最新的主节点地址告诉客户端。

### 消息丢失

Redis 主从采用异步复制，意味着当主节点挂掉时，从节点可能没有接收到全部的同步消息，这部分未同步的消息就丢失了。如果主从延迟特别大，那么丢失的数据就可能会特别多。

### Sentinel 基本用法

```python
from redis.sentinel import Sentinel
sentinel = Sentinel([('localhost', 26379)], socket_timeout=0.1)
sentinel.discover_master('mymaster')
sentinel.discover_slaver('mymaster')
```

Sentinel 默认端口为 26379，通过 Sentinel 对象的 discover_xxx 方法可以发现主从地址。通过 xxx_for 方法可以从连接池中拿出一个连接来使用。

连接池建立新连接时，会去查询主节点地址，然后跟内存中的主节点地址进行比对，如果变更了，就断开所有连接，重新使用新地址建立新连接。如果是旧的主节点挂掉了，那么所有正在使用的连接都会被关闭，然后在重连时就会用上新地址。

## Codis

在大数据高并发场景下，单个 Redis 实例往往会显得捉襟见肘。首先体现在内存上，单个 Redis 的内存不宜过大，内存过大会导致 rdb 文件过大，进一步导致主从同步时全量同步时间过长，在实例重启恢复时也会消耗很长的数据加载时间，特别是在云环境下，单个实例内存大小往往都是受限的。其次体现在 CPU 的利用率上，单个 Redis 实例只能利用单个核心，这单个核心要完成海量数据的存取和管理工作，压力会非常大。

正式在这样的大数据高并发的需求之下，Redis 集群方案应运而生。

Codis 是 Redis 集群方案之一。Codis 使用 Go 语言开发，它是一个代理中间件，和 Redis 一样也使用 Redis 协议对外提供服务，当客户端向 Codis 发送指令时，Codis 负责将指令转发到后面的 Redis 实例来执行，并将返回结果再转回给客户端。

Codis 上挂接的所有 Redis 实例构成一个 Redis 集群，当集群空间不足时，可以通过动态增加 Redis 实例来实现扩容需求。

因为 Codis 是无状态的，它只是一个转发代理中间件，通过启动多个 Codis 代理可以显著增加整体的 QPS 需求，还能起到容灾功能。

### Codis 分片原理

Codis 要负责将特定的 key 转发到特定的 Redis 实例，Codis 默认将所有的 key 划分为 1024 个槽位(slot)，它首先对客户端传过来的 key 进行 crc32 运算计算 hash 值，再将 hash 后的整数值对 1024 这个整数进行取模得到一个余数，这个余数就是对应 key 的槽位。每个槽位都会唯一映射到后面的多个 Redis 实例之一。Codis 会在内存中维护槽位和 Redis 实例的映射关系。

### 不同的 Codis 实例之间槽位关系如何同步

如果 Codis 的槽位映射关系只存储在内存里，那么不同的 Codis 实例之间的槽位关系就无法同步。所以 Codis 还需要一个分布式配置存储数据库专门用来持久化槽位关系。Codis 开始使用 zookeeper，后来连 etcd 也一块支持了。

Codis 将槽位关系存储在 zookeeper 中，并且提供了一个 Dashboard 可以用来观察和修改槽位关系，当槽位关系变化时，Codis Proxy 会监听到变化并重新同步槽位关系，从而实现多个 Codis Proxy 之间共享相同的槽位关系配置。

### 扩容

Codis 如何找到槽位对应的所有 key 呢？

>    Codis 对 Redis 进行了改造，增加了 SLOTSSCAN 指令，可以遍历指定 slot 下所有的 key。Codis 通过 SLOTSSCAN 扫描出待迁移槽位的所有 key，然后挨个迁移每个 key 到新的 Redis 节点。

在迁移过程中，Codis 还是会接收到新的请求打在当前正在迁移的槽位上，因为当前槽位的数据同时存在于新旧两个槽位中，Codis 如何判断该将请求转发到哪个具体实例呢？

>   Codis 无法判断迁移过程中的 key 究竟在哪个实例中，当 Codis 接收到位于正在迁移槽位中的 key 后，会立即强制对当前的单个 key 进行迁移，迁移完成后，再将请求转发到新的 Redis 实例。

在 Redis 中，所有 Scan 指令都是无法避免重复的，同样 Codis 自定义的 SLOTSSCAN 也是一样，但是这并不影响迁移，因为单个 key 被迁移一次后，在旧实例中它就被彻底删除了，也就不可能会被再次扫描出来。

### 自动均衡

Redis 新增实例，Codis 提供了自动均衡功能。自动均衡会在系统比较空闲的时候观察每个 Redis 实例对应的 slot 数量，如果不平衡，就会自动进行迁移。

### Codis 的代价

-   Codis 中所有的 key 分布在不同的 Redis 实例中，所以不支持事务
-    rename 操作也很危险
-   单个 key 对应的 value 不宜过大
-   网络开销过大
-   部署上增加了 zookeeper 运维的代价

### Codis 的优点

Codis 在设计上相对于 Redis Cluster 方案要简单很多。

### mget 指令的操作过程

mget 指令用于批量获取多个 key 的值，这些 key 可能会分布在多个 Redis 实例中。Codis 的策略是将 key 按照所分配的实例打散分组，然后依次对每个实例调用 mget 方法，最后将结果汇总为一个，再返回给客户端。

## Cluster

Redis Cluster 是 Redis 官方提供的集群化方案，与 Codis 有所不同，Redis Cluster 是去中心化的。

Redis Cluster 将所有数据划分为 16384 个槽位，它比 Codis 的 1024 个槽位划分得更为精细，每个节点负责其中一部分槽位。槽位的信息存储于每个节点中，它不像 Codis，不需要另外的分布式存储空间来存储节点槽位信息。

当 Redis Cluster 的客户端连接集群时，也会得到一份集群的槽位配置信息。这样当客户端要查找某个 key 时，可以直接定位到目标节点。这一点不同于 Codis，Codis 需要通过 Proxy 来定位目标节点，Redis Cluster 则直接定位。

### 槽位定位算法

Redis Cluster 默认会对 key 值使用 crc16 算法进行 hash，得到一个整数值，然后用这个整数值对 16384 进行取模来得到具体的槽位。Redis Cluster 还允许用户强制把某个 key 挂在特定槽位上。

### 跳转

当一个客户端向一个错误的节点发出了指令后，该节点会发现指令的 key 所在的槽位并不归自己管理，这时它会向客户端发送一个特殊的跳转指令携带目标操作的节点地址，告诉客户端去连接这个节点以获取数据。 

### 迁移

Redis Cluster 提供了工具 redis-trib 可以让运维人员手动调整槽位的分配情况，它使用 Ruby 语言开发，通过组合各种原生的 Redis Cluster 指令来实现。Redis 迁移的单位是槽，Redis 一个槽一个槽的进行迁移，当一个槽正在迁移时，这个槽就处于中间过渡状态。这个槽在源节点的状态为 migrating，在目标节点的状态为 importing，表示数据正从源节点流向目标节点。

迁移工具 redis-trib 首先会在源节点和目标节点设置好中间过渡状态，然后一次性获取源节点槽位的所有 key 列表(keysinslot 指令，可以部分获取)，再挨个 key 进行迁移。每个 key 的迁移过程是以源节点作为目标节点的"客户端"，源节点对当前的 key 执行 dump 指令得到序列化内容，然后通过"客户端"向目标节点发送 restore 指令携带序列化的内容作为参数，目标节点再进行反序列化就可以将内容恢复到目标节点的内存中，然后返回"客户端"OK，源节点"客户端"收到后再把当前节点的 key 删除掉就完成了单个 key 迁移的全过程。

>   注意迁移过程是同步的，在目标节点执行 restore 指令到源节点删除 key 之间，源节点的主线程会处于阻塞状态，直到 key 被成功删除。如果迁移过程中出现网络故障，整个槽的迁移只进行了一半，这时两个节点依旧处于中间过渡状态，待下次迁移工具重新连上时，会提示用户继续进行迁移。

在迁移过程中，如果 key 的内容很大，因为 migrate 指令是阻塞指令，会同时导致源节点和目标节点卡顿，影响集群稳定性。

### 容错

Redis 提供了一个参数 cluster-require-full-coverage 可以允许部分节点发生故障，其他节点还可以继续提供对外访问。

### 网络抖动

Redis Cluster 提供了一种选项 cluster-node-timeout，表示当某个节点持续 timeout 的时间失联时，才可以认定该节点出现故障，需要进行主从切换。还有另一个选项 cluster-slave-validity-factor 作为倍乘系数放大这个超时时间来宽松容错的紧急程度。如果这个系数为零，那么主从切换是不会抗拒网络抖动的，如果这个系数大于 1，它就成了主从切换的松弛系数。

### 可能下线(PFail)与确定下线(Fail)

Redis Cluster 是去中心化的，一个节点认为某个节点失联了并不代表所有的节点都认为它失联了，所以集群还得经过一次协商过程，只有当大多数节点都认定某个节点失联了，集群才认为该节点需要进行主从切换来容错。

Redis 集群节点采用 Gossip 协议来广播自己的状态以及改变对整个集群的认知。

### 槽位迁移感知

客户端保存了槽位和节点的映射关系表，它需要及时得到更新，才可以正常地将某条指令发送到正确的节点中。

MOVED 指令是用来纠正槽位的。如果将指令发送到了错误的节点，该节点发现对应的指令槽位不归自身管理，就会将目标节点的地址随同 MOVED 指令回复给客户端通知客户端去目标节点访问。这个时候客户端就会刷新自己的槽位关系表，然后重试指令，后续所有打在该槽位的指令都会转到目标节点。

ASKING 指令和 MOVED 不一样，它是用来临时纠正槽位的。如果当前槽位正处于迁移中，指令会先被发送到槽位所在的旧节点。如果旧节点存在数据，那就直接返回结果了，如果不存在数据，那么数据可能真的不存在，也可能在迁移目标节点上，所以旧节点会通知客户端去新节点尝试拿数据，看看新节点有没有。这时就会给客户端返回一个 asking error 携带上目标节点的地址。客户端收到这个 asking error 后，就会去目标节点尝试。客户端不会刷新槽位映射关系表，因为它只是临时纠正该指令的槽位信息，不影响后续指令。

### 集群变更通知

当服务器节点变更时，客户端应该立即得到通知以实时刷新自己的节点关系表。

1.  目标节点挂掉了，客户端会抛出一个 ConnectionError，紧接着会随机挑一个节点来重试，这时被重试的节点会通过 MOVED 指令告知目标槽位被分配到的新的节点地址。
2.  运维手动修改了集群信息，将主节点切换到其他节点，并将旧的主节点移出集群。这时打在旧的主节点上的指令会收到一个 ClusterDown 的错误，告知当前节点所在集群不可用。这时客户端就会关闭所有的连接，清空槽位映射关系表，然后向上抛出错误。待下一条指令过来时，就会重新尝试初始化节点信息。

