# 原理篇
## 线程 IO 模型

**Redis 是个单线程程序！** 除了 Redis 之外，Node.js、Nginx 都是单线程。

> Redis 单线程为什么还能这么快？
>
> 因为它的所有数据都在内存中，所有的运算都是内存级别的运算。

Redis 单线程通过 **"多路复用"** 处理高并发客户端连接。

### 非阻塞 IO

非阻塞 IO 在套接字对象上提供了一个选项 Non_Blocking，当这个选项打开时，读写方法不会阻塞。能读多少取决于内核为为套接字分配的读缓冲区内部的数据字节数，能写多少取决于内核为套接字分配的写缓存区的空闲字节数。读写方法都会通过返回值来告知程序实际读写了多少字节。

### 事件轮询（多路复用）

非阻塞 IO 会出现一个问题，当线程读数据时，何时可以读数据，何时可以写数据。事件轮询 API 就是用来解决这个问题的，它是操作系统提供给用户程序的 API。输入是读写描述符列表 read_fds & write_fds，输出是与之对应的可读可写事件。同时还提供了一个 timeout 参数，如果没有任何事件到来，就最多等待 timeout 的值的时间，此时线程处于阻塞状态。因为通过 select 系统调用同时处理多个通道描述符的读写事件，因此将这类系统调用称为多路复用 API。

### 指令队列

Redis 会将每个客户端套接字关联一个指令队列，客户端的指令通过队列来排队进行顺序处理，先到先服务。

### 响应队列

Redis 服务器通过响应队列来将指令的返回结果回复给客户端。如果队列为空，意味着连接暂时处于空闲状态，不需要获取写事件，从而降低 CPU 的负载。

### 定时任务

Redis 的定时任务会记录在一个被称为"最小堆"的数据结构中，在这个堆中，最快要执行的任务排在堆的最上方。在每个循环周期内，Redis 都会对最小堆里已经到时间点的任务进行处理。处理完毕后，将最快要执行的任务还需要的时间记录下来，这个时间就是 select 系统调用的 timeout 参数。

## 通信协议

### RESP（Redis Serialization Protocol）——Redis 序列化协议

Redis 协议将传输的结构数据分为 5 种最小单元类型，单元结束时统一加上回车换行符号 \r\n。

1.  单行字符串以"+"符号开头；
2.  多行字符串以"$"符号开头，后跟字符串长度；
3.  整数值以":"符号开头，后跟整数的字符串形式；
4.  错误信息以"-"符号开头；
5.  数组以"*"号开头，后跟数组长度。

单行字符串 hello world

```shell
+hello world\r\n
```

多行字符串 hello world

```shell
$11\r\nhello world\r\n
```

整数 1024

```shell
:1024\r\n
```

错误

```shell
-WRONGTYPE Operation against a key holding the wrong kind of value\r\n
```

数组 [1,2,3]

```shell
*3\r\n:1\r\n:2\r\n:3\r\n
```

Null

```shell
$-1\r\n
```

空串：空串用多行字符串表示，长度填 0

```shell
$0\r\n\r\n
```

### 客户端 --> 服务器

客户端向服务器发送的指令只有一种格式——多行字符串数组。

>   例如 set author codehole 会被序列化为
>
>   ```shell
>   *3\r\n$3\r\nset\r\n$6\r\nauthor\r\n$8\r\ncodehole\r\n
>   ```

### 服务器 --> 客户端

服务器向客户端回复的响应数据支持多种数据结构。

Redis 协议里有大量冗余的回车换行符，但是这不影响它成为互联网技术领域非常受欢迎的一个文本协议。

## 持久化

Redis 的持久化机制有两种，第一种是快照，第二种是 AOF 日志。快照是一次全量备份，AOF 日志是连续的增量备份。快照是内存数据的二进制序列化形式，在存储上非常紧凑，而 AOF 日志记录的是内存数据修改的指令记录文本。如果运行时间过长，AOF 日志会变得无比庞大，数据库重启后恢复时间变得非常长，所以需要定期重写 AOF 日志。

### 快照原理

Redis 使用操作系统的多进程 COW（Copy On Write）机制来实现快照的持久化。

### fork（多进程）

Redis 在持久化时会调用 glibc 的函数 fork 产生一个子进程，快照持久化完全交给子进程来处理，父进程继续处理客户端请求。

数据段是由很多操作系统的页面组合而成，当父进程对其中一个页面的数据进行修改时，会将被共享的页面复制一份分离出来，然后对这个复制的页面进行修改。这时子进程相应的页面是没有变化的。子进程因为看到的数据没有变化，可以非常安心的遍历数据。

### AOF 原理

AOF 日志存储的是 Redis 服务器的顺序指令序列，AOF 日志只记录对内存进行修改的指令记录。**先执行指令才将日志存盘。**

### AOF 重写

Redis 提供了 bgrewriteaof 指令用于对 AOF 日志进行瘦身，其原理就是开辟一个子进程对内存进行遍历，转换成一系列 Redis 的操作指令，序列化到一个新的 AOF 日志文件中。序列化完毕后再将操作期间发生的增量 AOF 日志追加到这个新的 AOF 日志文件中。

### fsync

AOF 日志是以文件的形式存在的，当程序对 AOF 日志文件进行写操作时，实际上是将内容写到了内核为文件描述符分配的一个内存缓存中，然后内核会异步将脏数据刷回到磁盘。

Linux 的 glibc 提供了 fsync(int fd) 函数可以将指定文件的内容强制从内核缓存刷到磁盘。只要 Redis 进程调用 fsync 函数就可以保证 AOF 日志不丢失。

### 运维

快照是一个非常耗时的操作：

1.  遍历整个内存，大块写磁盘会加重系统负载；
2.  AOF 的 fsync 是一个耗时的 IO 操作，它会降低 Redis 性能，同时也会增加系统 IO 负担。

通常情况都是 Redis 从结点进行持久化操作，但是有时会出现网路分区，造成主从数据不一致的情况，所以在生产环境需要做好实时监控工作。

### Redis 4.0 混合持久化

将 rdb 文件的内容和增量的 AOF日志文件放在一起，AOF 只记录从持久化开始到持久化结束之间发生的增量 AOF 日志，通常这部分 AOF 日志很小。于是 Redis 重启的时候，可以先加载 rdb 的内容，然后再重放增量 AOF 日志，就可以完全替代之前的 AOF 全量文件重放。

## 管道

### Redis 的消息交互

管道本质上是由客户端提供的服务，将两次读和两次写合并。客户端通过对管道中的指令列表改变读写顺序就可以大幅节省 IO 时间，管道中指令越多，效果越好。

### 管道压力测试

Redis 自带了一个压力测试工具 redis-benchmark，使用这个工具就可以进行管道测试。

```shell
redis-benchmark -t set -q
```

```shell
redis-benchmark -t set -P 2 -q
```

`-P`参数表示单个管道内并行的请求数量。并不是增大`P`参数就可以无限增大`QPS`，因为会有 CPU 瓶颈。

### 深入理解管道本质

1.  客户端进程调用 write 将消息写到操作系统内核为套接字分配的发送缓冲 send buffer 中。
2.  客户端操作系统内核将发送缓冲的内容发送到网卡，网卡硬件将数据通过"网际路由"送到服务器的网卡。
3.  服务器操作系统内核将网卡的数据放到内核为套接字分配的接收缓冲 recv buffer 中。
4.  服务器进程调用 read 从接收缓冲中取出消息进行处理。
5.  服务器进程调用 write 将响应消息写到内核为套接字分配的发送缓冲 send buffer 中。
6.  服务器操作系统内核将发送缓冲的内容发送到网卡，网卡硬件将数据通过"网际路由"送到客户端的网卡。
7.  客户端操作系统内核将网卡的数据放到内核为套接字分配的接收缓冲 recv buffer 中。
8.  客户端进程调用 read 从接收缓冲中取出消息返回给上层业务逻辑进行处理。
9.  结束。

对于管道来说，连续的 write 操作根本不耗时，之后第一个 read 操作会等待一个网络的来回开销，然后所有的响应消息就都已经送回到内核的读缓冲中，后续的 read 操作直接就可以从缓冲中拿到结果，瞬间就返回了。

## 事务

### Redis 事务的基本用法

Redis 事务指令分别是 multi、exec、discard。multi 指示事务的开始，exec 指示事务的执行，discard 指示事务的丢弃。

```shell
> multi
OK
> incr books
QUEUED
> incr books 
QUEUED
> exec
(integer) 1
(integer) 2
```

因为 Redis 的单线程的特性，可以保证命令"原子性"执行。

### 原子性

事实上，Redis 的事务根本不具备"原子性"，而是仅仅满足事务的"隔离性"中的串行化——当前执行的事务有着不被其他事务打断的权利。

### discard

Redis 为事务提供了一个 discard 指令，用于丢弃事务缓存队列中的所有指令，在 exec 执行之前。

### 优化

Redis 事务在发送每个指令到事务缓存队列时都要经过一次网络读写，当一个事务内部的指令较多时，需要的网络 IO 时间也会线性增长，所以通常 Redis 的客户端在执行事务时都会结合 pipeline 一起使用，这样可以将多次 IO 操作压缩为单词 IO 操作。

### watch

Redis 中的 watch 是一种乐观锁。watch 会在事务开始之前盯住一个或多个关键变量，当事务执行时，Redis 会检查关键变量自 watch 之后是否被修改了。如果关键变量被更改，exec 指令就会返回 NULL 回复告知客户端事务执行失败，这个时候客户端一般会选择重试。

```shell
> watch books 
OK
> incr books
(integer) 1
> multi
OK
> incr books
QUEUED
> exec
(nil)
```

### 注意事项

Redis 禁止在 multi 和 exec 之间执行 watch 指令，而必须在 multi 之前盯住关键变量，否则会出错。

## PubSub

Redis 消息队列有一个弊端，就是不支持消息的多播机制。

### 消息多播

消息多播允许生产者只生产一次消息，由中间件负责将消息复制到多个消息队列，每个消息队列由相应的消费组进行消费。它是分布式系统常用的一种解耦方式，用于将多个消费组的逻辑进行拆分。支持了消息多播，多个消费组的逻辑就可以放到不同的子系统中。

### PubSub

Redis 使用 PubSub 支持消息多播，也就是 PublisherSubscriber。

```python
import time 
import redis 

client = redis.StrictRedis()
p = client.pubsub()

time.sleep(1)
print p.get_message()
client.publish("codehole", "java comes")

time.sleep(1)
print p.get_message()
client.publish("codehole", "python comes")

time.sleep(1)
print p.get_message()
print p.get_message()
```

Redis PubSub 的生产者和消费者是不同的连接，也就是上面这个例子实际上使用了两个 Redis 连接。

### 模式订阅

上面提到的订阅模式是基于名称订阅的，消费者订阅一个主题必须明确指定主题的名称。为了简化订阅的繁琐，Redis 提供了模式订阅功能 Pattern Subscribe，这样就可以一次订阅多个主题，即使生产者新增加了同模式的主题，消费者也可以立即收到消息。

```shell
# 用模式匹配一次订阅多个主题，主题以 codehole. 字符开头的消息都可以接收到
> psubscribe codehole.*
1) "psubscribe"
2) "codehole.*"
3) (integer) 1
```

### 消息结构

```json
{'pattern': None, 'type': 'subscribe', 'channel': 'codehole', 'data': 1L}
```

-   data 是消息内容，一个字符串；
-   channel 表示当前订阅的主题名称；
-   type 表示消息类型。如果是一个普通消息，类型就是 message；如果是控制消息，比如订阅指令的反馈，类型就是 subscribe；如果是模式订阅的反馈，类型就是 psubscribe；取消订阅指令的反馈 unsubscribe 和 punsubscribe；
-   pattern 表示当前消息是使用哪种模式订阅得到的。

### PubSub 缺点

1.  如果有一个消费者服务挂掉，生产者继续发送消息，当该消费者重新上线时，在断连期间生产者发送的消息，对于这个消费者来说就是彻底丢失了；
2.  如果 Redis 停机重启，PubSub 的消息是不会持久化的。

正是由于以上原因，PubSub 在消息队列领域几乎没有应用场景。

### 补充

Redis 5.0 增加了 Stream 数据结构，这个功能带来了持久化的消息队列。

## 小对象压缩

### 32 bit vs 64 bit

Redis 如果使用 32 bit 进行编译，内部所有数据结构所使用的指针空间占用会少一半。

### 小对象压缩存储(ziplist)

Redis 的 ziplist 是一个紧凑的字节数组结构，每个元素之间都是紧挨着的。如果它存储的是 hash 结构，那么 key  和 value 会作为两个 entry 被相邻存储。如果它存储的是 zset 结构，那么 value 和 score 会作为两个 entry 被相邻存储。

当集合对象的元素不断增加，或者某个 value 值过大，这种小对象存储也会被升级为标准结构。

### 内存回收机制

Redis 并不总是将空间内存立即归还给操作系统。操作系统是以页为单位来回收内存的，这个页上只要还有一个 key 在使用，那么它就不能被回收。Redis 虽无法保证立即回收已经删除的 key 的内存，但是它会重新使用那些尚未回收的空闲内存。

### 内存分配算法

Redis 内存分配算法通过第三方库实现。目前可以使用 jemalloc(facebook)库来管理内存，也可以切换到 tcmalloc(goole)库，Redis 默认使用 jemalloc。通过 info memory 指令可以看到 Redis 的mem_allocator 使用了 jemalloc。