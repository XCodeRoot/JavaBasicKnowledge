### 几个基本概念

#### 内存可见性
内存可见性是指线程之间的可见性，当一个线程修改了共享变量时，另一个线程可以读取到这个修改后的值。

#### 重排序
为了优化程序性能，对原有的指令执行顺序进行优化重新排序。

#### happens-before 规则
这是一个给程序员使用的规则，只要程序员在编写代码时遵循 happens-before 规则，JVM 就能保证指令在多线程之间的顺序性符合程序员的预期。

### volatile 的内存语义
volatile 主要有以下两个功能：
- 保证变量的内存可见性
- 禁止 volatile 变量与普通变量重排序

#### 内存可见性
所谓内存可见性，指的是当一个线程对 volatile 修饰的变量进行 **写操作** 时，JMM 会立即把该线程对应的本地内存中的共享变量的值刷新到主内存；当一个线程对 volatile 修饰的变量进行 **读操作** 时，JMM 会立即把该线程对应的本地内存置为无效，从主内存中读取共享变量的值。

#### 禁止重排序
JVM 通过内存屏障限制处理器的重排序，从硬件层面来说，内存屏障分为两种：读屏障（Load Barrier）和写屏障（Store Barrier），作用：
1. 阻止屏障两侧的指令重排序；
2. 强制把写缓冲区/高速缓存中的脏数据等写回主内存，或者让缓存中相应的数据失效。


编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。编译器选择了一个比较保守的 JMM 内存屏障插入策略，这样可以保证在任何处理器平台，任何程序中都能得到正确的 volatile 内存语义。这个策略是：
- 在每个 volatile 写操作前插入一个 StoreStore 屏障；
- 在每个 volatile 写操作后插入一个 StoreLoad 屏障；
- 在每个 volatile 读操作后插入一个 LoadLoad 屏障；
- 在每个 volatile 读操作后再插入一个 LoadStore 屏障。
![](img/内存屏障.png)
> LoadLoad 屏障：对于这样的语句 Load1；LoadLoad；Load2，在 Load2 及后续读取操作要读取的数据被访问前，保证 Load1 要读取的数据被读取完毕。
>
> StoreStore 屏障：对于这样的语句 Store1；StoreStore；Store2，在 Store2 及后续写入操作执行前，这个屏障会把 Store1 强制刷新到内存，保证 Store1 的写入操作对其它处理器可见。
>
> LoadStore 屏障：对于这样的语句 Load1；LoadStore；Store2，在 Store2 及后续写入操作被刷出前，保证 Load1 要读取的数据被读取完毕。
>
> StoreLoad 屏障：对于这样的语句 Store1；StoreLoad；Load2，在 Load2 及后续所有读取操作执行前，保证 Store1 的写入对所有处理器可见。它的开销是四种屏障中最大的（冲刷写缓冲器，清空无效化队列）。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。

重排序规则：
1. 如果第一个操作是 volatile 读，那无论第二个操作是什么，都不能重排序；
2. 如果第二个操作是 volatile 写，那无论第一个操作是什么，都不能重排序；
3. 如果第一个操作是 volatile 写，第二个操作是 volatile 读，那不能重排序。

### volatile 的用途
volatile 有着与锁相同的内存语义，可以作为一个"轻量级"的锁来使用，但是由于 volatile 仅仅保证对单个 volatile 变量的读/写具有原子性，而锁可以保证整个 **临界区代码** 的执行具有原子性，所以在 **功能上，锁比 volatile 更强大；在性能上，volatile 更具有优势。**

